<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发学习总结(一)]]></title>
    <url>%2F2019%2F07%2F29%2FAndroid%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Android开发概述以及开发工具 Android开发概述 Android是Google开发的操作系统 Android是一种基于Linux的自由及开放源代码的操作系统，Android 分为四个层，从高层到低层分别是应用程 序层、应用程序框架层、系统运行库层和 Linux 内核层。 Android开发是移动应用开发的表现形式之一 其它表现形式:iOS,H5App,Native+H5,RN,ionic等. Android四大基本组件:Activity、Service、Broadcast Receivet、Content Provider. 特点:系统开源,跨平台,有丰富的应用. Android开发环境 ​ Android基于java的,早期使用eclipse作为IDE,现在比较流行的是Android Studio.它基于IntelliJ IDEA类似Echpse ADT，Android Studio提供了集成的 Android开发工具。相比较以前Eclipse，它自己内部就集成了SDK等，方便开发。通常情况下，在正常安装JDK后，继续安装 Android Studio后，便可直接使用了。 第一个Android应用 ​ 使用Android Studio创建一个安卓应用,我们可以在app/src/main/java/自定义包名/ 下看到MainActivity,这是默认的Activity主入口,直接启动项目就可以在虚拟机环境下看到默认的helloworld页面了. 新建一个Activity步骤: 新建一个java文件,继承于AppCompatActivity类并重写onCreat()方法,设置一个视图View. 在AndroidManifest.xml文件中注册新建的activity实体. 在res/layout包下创建一个xml视图文件,用于展示视图.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 新手搭建教程]]></title>
    <url>%2F2019%2F07%2F23%2FHEXO-%E6%96%B0%E6%89%8B%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[HEXO 新手指南 1.简介 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 视频观看地址:https://www.bilibili.com/video/av44544186/?spm_id_from=333.788.videocard.15 2.安装必要的软件 进入Node.js官网安装nodeJs,安装完毕后命令行输入node -v 显示版本号,输入 npm -v 显示版本号即安装成功 进入git官网安装git,具体百度 安装hexo, 在命令行中输入 npm install -g hexo-cli 命令行输入hexo -v 显示版本号即安装成功 3. 搭建步骤 1.初始化项目 ​ 在任意目录创建一个文件夹,此文件夹就是博客的工程目录了,比如我创建的路径为 E:/blob/,然后在cmd中进入工程文件目录,输入命令行 hexo init 查看blog目录可以看到生成了很多文件,并且还生成了一个helloword文档,在source/_post目录下,然后输入 hexo s 即可启动项目,浏览器输入localhost:4000即可看到最简单的模型 2. 更换blog主题 ​ 在官网上找一个喜欢的主题或者使用视频里的yilia主题. 在工程根目录使用git bash 克隆工程或者直接下载zip包 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 打开根目录的_config.yml文件,设置主题 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: Butterfly 3. 部署项目到github上 创建一个github账号:https://github.com/ 创建一个repo仓库 Repository name: 账号名.github.io (必须) 进入cmd 输入命令 npm install --save hexo-deployer-git 等待插件下载完成后修改_config.yml,设置仓库地址 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/zly1024/zly1024.github.io.git branch: master 部署工程到git hexo d 浏览器访问https://zly1024.github.io 即可看到博客页面(这里输入自己的项目名) 4. 创建新博客 hexo new "博客名" 然后可以以写md文件的软件打开撰写. 重新部署到git hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oauth框架搭建]]></title>
    <url>%2F2019%2F07%2F22%2Foauth%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[oauth2总结 前言 1. 什么是oauth OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 2. 运行流程图 （A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 3. 四种授权模式 1. 授权码模式 授权码模式是四种模式中最繁琐也是最安全的一种模式。 client向资源服务器请求资源，被重定向到授权服务器（AuthorizationServer） 浏览器向资源拥有者索要授权，之后将用户授权发送给授权服务器 授权服务器将授权码（AuthorizationCode）转经浏览器发送给client client拿着授权码向授权服务器索要访问令牌 授权服务器返回Access Token和Refresh Token给cilent 这种模式是四种模式中最安全的一种模式。一般用于client是Web服务器端应用或第三方的原生App调用资源服务的时候。因为在这种模式中AccessToken不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最大限度的减小了AccessToken泄漏的风险。 1.获取授权码请求uri：/oauth/authorize 参数： client_id：客户端id。 response_type：授权类型，此值固定为“code”。 redirect_uri：成功授权后的回调地址 2.获取token请求uri：/oauth/token 参数: client_id：客户端id。 client_secret：客户端密钥 grant_type：授权类型，固定为authorization_code code：授权码 redirect_uri：重定向地址 2. 密码模式 用户将认证密码发送给client client拿着用户的密码向授权服务器请求Access Token 授权服务器将Access Token和Refresh Token发送给client 这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用。 1.获取token请求uri：/oauth/token 参数： username：用户名 password：用户密码 client_id：客户端id client_secret：客户端密钥 grant_type：授权类型，固定为password 3. 客户端模式 这是一种最简单的模式，只要client请求，我们就将AccessToken发送给它。 client向授权服务器发送自己的身份信息，并请求AccessToken 确认client信息无误后，将AccessToken发送给client 这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因此这种模式一般用来提供给我们完全信任的服务器端服务。在这个过程中不需要用户的参与。 1.获取token请求uri：/oauth/token 参数： client_id：客户端id client_secret：客户端密钥 grant_type：授权类型，固定为client_credentials 4. 简化模式 简化模式相对于授权码模式省略了，提供授权码，然后通过服务端发送授权码换取AccessToken的过程。 client请求资源被浏览器转发至授权服务器 浏览器向资源拥有者索要授权，之后将用户授权发送给授权服务器 授权服务器将AccessToken以Hash的形式存放在重定向uri的fargment中发送给浏览器 浏览器访问重定向URI 资源服务器返回一个脚本，用以解析Hash中的AccessToken 浏览器将Access Token解析出来 将解析出的Access Token发送给client 一般简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法使用授权码模式。 注：一般使用前三种模式 4. oauth授权服务器搭建 版本： springboot：1.4.5 security：1.4.5 oauth2：2.0.13 redis：4.0 1. 创建springboot工程并引入oauth相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--jwttoken依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--oauth客户端详情数据库存取相关依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 2. OauthConfig配置 @Configuration/** * @EnableAuthorizationServer * 工具方法，用来在当前应用context里(必须是一个DispatcherServlet context) * 开启一个授权server(例如AuthorizationEndpoint)和一个TokenEndpoint。 * server的多个属性可以通过自定义AuthorizationServerConfigurer类型 * (如AuthorizationServerConfigurerAdapter的扩展)的Bean来定制 */@EnableAuthorizationServer@AutoConfigureAfter(WebSecurityConfig.class)public class OAuth2Config extends AuthorizationServerConfigurerAdapter &#123; //AuthenticationManager为认证入口的接口 //通过该接口可以获得用户相关信息、安全实体的标识以及认证请求的上下文信息 @Autowired private AuthenticationManager authenticationManager; @Autowired private DataSource dataSource; @Autowired private RedisCacheProperties redisCacheProperties; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthenticationProvider authenticationProvider; @Value("$&#123;jwt.store.password:zaq12wsx&#125;") private String jwtPass; //jwtToken转换bean 替换oauth默认生成的token @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); KeyPair keyPair = new KeyStoreKeyFactory( new ClassPathResource("jwt.jks"), "zaq12wsx".toCharArray()) .getKeyPair("jwt"); converter.setKeyPair(keyPair); return converter; &#125; //jedis连接工厂bean @Bean("connection4jwt") public JedisConnectionFactory jedisConnectionFactory() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxWaitMillis(redisCacheProperties.getMaxWaitMillis()); jedisPoolConfig.setMaxIdle(redisCacheProperties.getMaxIdle()); jedisPoolConfig.setMaxTotal(redisCacheProperties.getMaxTotal()); JedisConnectionFactory factory = new JedisConnectionFactory(jedisPoolConfig); factory.setHostName(redisCacheProperties.getHost()); factory.setPort(redisCacheProperties.getPort()); factory.setDatabase(1); factory.setPassword(redisCacheProperties.getPassword()); factory.afterPropertiesSet(); return factory; &#125; //设置Token redis存储bean @Bean public TokenStore tokenStore() &#123; RedisTokenStore redisTokenStore = new RedisTokenStore(jedisConnectionFactory()); redisTokenStore.setPrefix("auth-server.jwt"); return redisTokenStore; &#125; //设置基于数据库的客户端详情存取 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.jdbc(dataSource); &#125; //用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务(token services)。 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager) .accessTokenConverter(jwtAccessTokenConverter())//配置jwt转换器 .authorizationCodeServices(new AuthorizationCodeServices(dataSource))//配置授权码 .tokenStore(tokenStore()).reuseRefreshTokens(false)//配置token存储 .userDetailsService(userDetailsService);//配置基于数据库验证账户密码 //oauth获取token，鉴权token的逻辑都在DefaultTokenServices中，它实现了两个接口 //AuthorizationServerTokenServices ：创建，刷新，获取访问令牌 //ResourceServerTokenServices ：加载凭据，获取token的详情 // 构建TokenServices TokenServices tokenServices = new TokenServices(); tokenServices.setTokenStore(tokenStore()); tokenServices.setSupportRefreshToken(true); tokenServices.setReuseRefreshToken(false); //从数据库获取client详情 tokenServices.setClientDetailsService(endpoints.getClientDetailsService()); tokenServices.setTokenEnhancer(jwtAccessTokenConverter()); endpoints.tokenServices(tokenServices); &#125; //用来配置令牌端点(Token Endpoint)的安全约束. @Override public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception &#123; oauthServer.tokenKeyAccess("permitAll()").checkTokenAccess( "isAuthenticated()").allowFormAuthenticationForClients(); &#125; //ProviderManager 为AuthenticationManager 的认证实现类 //认证方法authenticate() /** 认证流程：1.封装UsernamePasswordAuthenticationToken（主要是将用户输入的用户名密码进行封装，并提供 给AuthenticationManager进行验证，验证成功后，返回一个认证成功的 UsernamePasswordAuthenticationToken对象）设置用户未认证 2.ProviderManager.authenticate() 轮询成员变量List&lt;AuthenticationProvider&gt; providerList，只要其supports函数返回true，就执行该AuthenticationProvider的authenticate 方法，验证成功后重新组装UsernamePasswordAuthenticationToken，并设置用户已认证 注，若要自定义认证方式，则实现AuthenticationProvider接口即可 **/ @Bean public ProviderManager authenticationManager() &#123; List&lt;AuthenticationProvider&gt; providerList = new ArrayList&lt;&gt;(); providerList.add(authenticationProvider); return new ProviderManager(providerList); &#125;&#125; DefaultTokenServices详解：https://www.jianshu.com/p/1fba33b26976 AuthenticationManager 详解：https://www.cnblogs.com/xuwenjin/p/9565356.html 3. AuthenticationProvider实现类 核心代码： @Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; String userName = authentication.getName(); String password = (String) authentication.getCredentials(); UserDetails userDetails = userDetailsService.loadUserByUsername(userName); if (userDetails == null) &#123; logger.debug("Authentication failed: user doesn't exists!"); throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; else &#123; String userPassWord = userDetails.getPassword(); if (userPassWord.equals(password) || userPassWord.equals(PasswordUtil.encodePassword(password, userName)) || userPassWord.equals(PasswordUtil.encodePassword(passwordMd5Encode(password), userName))) &#123; //校验用户是否已过期或被锁住等 if (UserLoginHoldUtil.canUserLoginByAuth(userDetails)) &#123; return new UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities()); &#125; else &#123; logger.debug("Authentication failed: user cannot login!"); throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; &#125; else &#123; logger.debug("Authentication failed: password does not match stored value!"); throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; &#125;&#125; 4. WebSecurityConfig 配置 /** * WebSecurityConfigurerAdapter是默认情况下spring security的http配置 其过滤器链默认值为100 */@Configuration@EnableWebSecurity//指定的类加载完了再加载本类@AutoConfigureAfter(AuthProviderConfig.class)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value("$&#123;security.success.defaultTargetUrl:&#125;") private String defaultTargetUrl; @Autowired private AuthenticationProvider authenticationProvider; @Override protected void configure(HttpSecurity http) throws Exception &#123; //security本身是有认证页面的，这里设置security的成功失败的路径等等 SimpleUrlLogoutSuccessHandler logoutSuccessHandler = new SimpleUrlLogoutSuccessHandler(); logoutSuccessHandler.setTargetUrlParameter("redirect_uri"); SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler(); successHandler.setTargetUrlParameter("redirect_uri"); successHandler.setDefaultTargetUrl(defaultTargetUrl); http.httpBasic().disable().csrf().disable().logout().logoutSuccessHandler(logoutSuccessHandler).and().formLogin().loginPage("/login").successHandler(successHandler).defaultSuccessUrl(defaultTargetUrl).permitAll().and().authorizeRequests() /** 此处是设置哪些http请求通过，哪些http请求需要被认证， ResourceServerConfigurerAdapter中的http设置会跟web中的功能一样 不过ResourceServerConfigurerAdapter的过滤器链默认执行顺序为3 **/ .antMatchers("/oauth/**").permitAll() .antMatchers("/register", "/usr/verifyUserName", "/usr/sendVerifyCode", "/usr/register").permitAll() .antMatchers("/fp_phone", "/fp_reset", "/usr/fp/verifyPhoneEffect", "/usr/fp/resetPwd").permitAll() .antMatchers("/MP_verify_RIPzMyhi7TAhrr1q.txt").permitAll() //保证微信内不提示安全验证信息 .anyRequest().authenticated(); &#125; //security认证配置，使用自定义的认证类 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authenticationProvider); &#125;&#125; ResourceServerConfigurerAdapter 与WebSecurityConfigurerAdapter 对比详解：https://www.jianshu.com/p/fe1194ca8ecd 5. 授权码生成实现类AuthorizationCodeServices 核心代码： @Overridepublic String createAuthorizationCode(OAuth2Authentication authentication) &#123; String code = generator.generate(); store(code, authentication); return code;&#125; 继承于默认实现类JdbcAuthorizationCodeServices：存储code于数据库表oauth_code中，删除code 又继承于默认实现类RandomValueAuthorizationCodeServices 5. 资源服务器搭建 1. 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;&lt;/dependency&gt; 2. ResourceServerConfig 配置 /** * 资源服务配置. * * @author zly */@Configuration/**资源服务器通过 @EnableResourceServer 注解来开启一个 OAuth2AuthenticationProcessingFilter 类型的过滤器解析令牌的方法1.使用 DefaultTokenServices 在资源服务器本地配置令牌存储、解码、解析方式**/@EnableResourceServer@ConditionalOnProperty(name = "security.enabled", havingValue = "true")public class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; /*每个服务依赖时资源id为应用名字*/ @Value("$&#123;spring.application.name:spring-boot-application&#125;") private String resourceId; @Value("$&#123;jwt.store.password:zaq12wsx&#125;") private String jwtPass; @Override public void configure(ResourceServerSecurityConfigurer resources) &#123; resources.resourceId(resourceId);//（必须配） //资源服务配置tokenServices（非必须） resources.tokenServices(defaultTokenServices()); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.requestMatcher(new OAuthRequestedMatcher()).authorizeRequests().antMatchers(HttpMethod.OPTIONS).permitAll() .anyRequest().authenticated(); &#125; @Bean public UserDetailsService userDetailsService() &#123; return new OAuthUserDetailsService(); &#125; //DefaultAccessTokenConverter又使用DefaultUserAuthenticationConverter来做用户密码角色相关 //若为非对称加密必须配 @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); KeyPair keyPair = new KeyStoreKeyFactory( new ClassPathResource("jwt.jks"), jwtPass.toCharArray()) .getKeyPair("jwt"); converter.setKeyPair(keyPair); //可不配置 DefaultAccessTokenConverter accessTokenConverter = new DefaultAccessTokenConverter(); DefaultUserAuthenticationConverter userAuthenticationConverter = new DefaultUserAuthenticationConverter(); userAuthenticationConverter.setUserDetailsService(userDetailsService()); accessTokenConverter.setUserTokenConverter(userAuthenticationConverter); converter.setAccessTokenConverter(accessTokenConverter); return converter; &#125; //若不配置会使用内存存储（则无法解析） //配置jwtTokenStore，解析token用到的是jwtAccessTokenConverter @Bean public TokenStore tokenStore() &#123; JwtTokenStore tokenStore = new JwtTokenStore(jwtAccessTokenConverter()); return tokenStore; &#125; //（非必须） @Bean public ResourceServerTokenServices defaultTokenServices() &#123; final DefaultTokenServices defaultTokenServices = new DefaultTokenServices(); defaultTokenServices.setTokenEnhancer(jwtAccessTokenConverter()); defaultTokenServices.setTokenStore(tokenStore()); return defaultTokenServices; &#125; //（非必须） //http请求过滤 private static class OAuthRequestedMatcher implements RequestMatcher &#123; public boolean matches(HttpServletRequest request) &#123; String auth = request.getHeader("Authorization"); // Determine if the client request contained an OAuth Authorization boolean haveOauth2Token = (auth != null) &amp;&amp; StringUtils.startsWithIgnoreCase(auth, "Bearer"); boolean haveAccessToken = request.getParameter("access_token") != null; return haveOauth2Token || haveAccessToken; &#125; &#125;&#125; ResourceServerConfig详解：https://www.jianshu.com/p/6dd03375224d 3. WebSecurityConfig 配置 /** * @author zly */@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)//@EnableGlobalMethodSecurity(prePostEnabled = true)@ConditionalOnProperty(name = "security.enabled", havingValue = "true") public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and() .authorizeRequests() .antMatchers(HttpMethod.OPTIONS).permitAll() .antMatchers("/wxAdapter", "/wxAdapter/*").permitAll() .anyRequest().authenticated() .and().httpBasic() .and().csrf().disable(); &#125;&#125; 最好的放开方式，resourceServerConfig中不配置请求过滤，在security的配置中使用，因为security在 yml文件里有已存在的标签来控制。 6. 认证授权全流程过程以及源码分析 1.第一步：登陆认证 用户访问受限的资源服务页面,页面判断code的存在跳转到授权服务器登陆页面（我的redirect_uri设置为localhost：8083，即我资源服务器地址为localhost：8083)，请求url为： http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=shopapp&amp;redirect_uri=http://localhost:8083 获取code时先判断用户是否已认证： security认证入口： Authentication.authenticate():默认实现类ProvideManager 此类有一个成员变量List providerList = new ArrayList&lt;&gt;(); 最后执行的是AuthenticationProvider.authenticate();下图是自定义的AuthenticationProvider对象 登陆认证完成之后会返回Authentication对象（实现类UsernamePasswordAuthenticationToken），然后会将对象中的password清除 最后会将对象存入SecurityContext中 之后会再次回到获取code的接口中，生成code，然后oauth会跳转到redirect_uri并带上code和state参数。 2.第二步：授权 在资源页面js中根据code和redirect_uri手动构造请求访问授权服务器获取token 经过校验传递的参数是否合法之后，会进入到TokenGranter接口-----&gt;AbstractTokenGranter抽象类的grant()方法获取token 最终的执行方法是DefaultTokenServices.createAccessToken() 若DefaultTokenServices中配置了TokenEnhance会执行其enhance方法替换之前生成的token格式 一般是配置jwtAccessTokenConverter 生成token成功之后会返回ResponseEntity对象，最终返回给前端，存入localstage或页面其他地方。 3.第三步：鉴权 用户访问资源需在请求头带上Authorization键，值为bearer+空格+accessToken，就能进入鉴权入口进行鉴权，鉴权通过之后即可访问资源 然后使用Oauth2AuthenticationManager的authenticate方法鉴权认证 再进入DefaultTokenServices的loadAuthentication方法 1.执行jwtTokenStore–jwtAccessTokenConverter–DefaultAccessTokenConverter里d的方法extractAccessToken()并返回OAuth2AccessToken对象 2.执行jwtTokenStore–jwtAccessTokenConverter–DefaultAccessTokenConverter里的方法extractAuthentication()，并使用DefaultUserAuthenticationConverter的extractAuthentication方法(若配置了userDetailsService，则会去从数据库中获取角色，优先使用的时数据库返回的user和角色)返回UsernamePasswordAuthenticationToken对象 解析token方法 鉴权认证通过之后，比对resourceIds和资源本身的resourceId 若比对成功则鉴权通过，可以访问到需访问的资源]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new "My New Post" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
