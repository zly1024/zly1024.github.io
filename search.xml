<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发学习总结(二)]]></title>
    <url>%2F2019%2F07%2F30%2FAndroid%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Activity布局和视图总结 1. 线性布局 ​ 线性布局使用&lt;LinearLayout&gt;标签,LinearLayout 是一个视图组，它所有的子视图都在一个方向对齐，水平或者垂直。你可以指定布局的方向通过 android:orientation 属性。 ​ LinearLayout的所有子视图排列都是一个靠着另一个，因此垂直列表每行仅仅有一个子视图，不管有多宽。水平列表只能有一行的高度（最高子视图的高度加上边距距离）。LinearLayout 期望子视图之间都有margin，每个子视图都有gravity。 ​ 线性布局也支持给个别的子视图设定权重，通过android:layout_weight属性 ​ 示例: &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp"/&gt;&lt;/LinearLayout&gt; 实现的效果为 ###2.相对布局 ​ 相对布局使用&lt;RelativeLayout&gt;,RelativeLayout是一个视图组，显示相对位置的子视图。每个视图的位置可以指定为相对于同级元素（例如，在另一个视图的左侧或下方）或相对于父RelativeLayout区域的位置（例如与中心的底部，左侧对齐）。 ​ RelativeLayout是用于设计用户界面的非常强大的实用程序，因为它可以消除嵌套视图组并保持布局层次结构平整，从而提高性能。如果您发现自己使用了多个嵌套LinearLayout组，则可以用一个替换它们RelativeLayout。 一些常用的相对布局的属性: android:layout_centerHrizontal //水平居中android:layout_centerVertical //垂直居中android:layout_centerInparent //相对于父元素完全居中android:layout_alignParentBottom //贴紧父元素的下边缘android:layout_alignParentLeft //贴紧父元素的左边缘android:layout_alignParentRight //贴紧父元素的右边缘android:layout_alignParentTop //贴紧父元素的上边缘android:layout_alignWithParentIfMissing //如果对应的兄弟元素找不到的话就以父元素做参照物android:layout_centerHorizontal="true" //水平居中android:layout_centerVertical="true" //竖直居中android:layout_centerInParent="true" //相对父控件居中 android:layout_below //在某元素的下方android:layout_above //在某元素的的上方android:layout_toLeftOf //在某元素的左边android:layout_toRightOf //在某元素的右边android:layout_alignTop //本元素的上边缘和某元素的的上边缘对齐android:layout_alignLeft //本元素的左边缘和某元素的的左边缘对齐android:layout_alignBottom //本元素的下边缘和某元素的的下边缘对齐android:layout_alignRight //本元素的右边缘和某元素的的右边缘对齐 示例: &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;TextView android:id="@+id/tx_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp"/&gt; &lt;TextView android:id="@+id/tx_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp" android:layout_below="@+id/tx_1"/&gt; &lt;!-- 用android:layout_below属性指定该控件位于哪个位置--&gt; &lt;TextView android:id="@+id/tx_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="50sp" android:layout_below="@+id/tx_2"/&gt; &lt;/RelativeLayout&gt; 3. 列表视图ListView ​ ListView是一个显示可滚动项列表的视图组。列表项将自动插入到列表中，使用Adapter从数据库或数据库查询等源中提取内容，并将每个项目结果转换为放入列表中的视图。 ​ 示例: xml中 &lt;!--activity_list_view.xml--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="10dp" &gt; &lt;ListView android:id="@+id/alv_lv" android:layout_width="match_parent" android:layout_height="wrap_content" android:listSelector="@drawable/list_item" /&gt;&lt;/LinearLayout&gt;&lt;!--list_item.xml--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;!--设置press特效--&gt; &lt;item android:state_pressed="true" android:drawable="@color/colorGray"/&gt; &lt;!--设置选中特效--&gt; &lt;item android:state_selected="true" android:drawable="@color/colorGray"/&gt; &lt;!--未选中,默认特效为透明--&gt; &lt;item android:drawable="@color/colorTransparent"/&gt;&lt;/selector&gt;&lt;!--layout_list_item.xml--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal" android:padding="15dp" &gt; &lt;ImageView android:id="@+id/lliiv" android:layout_width="100dp" android:layout_height="100dp" android:scaleType="centerCrop" android:background="#000" /&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:paddingLeft="10dp" &gt; &lt;TextView android:id="@+id/llitx_1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="hello" android:textSize="20sp" android:textColor="@color/colorBlack" /&gt; &lt;TextView android:id="@+id/llitx_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="2019-7-25" android:textSize="18sp" android:textColor="@color/colorGray" android:layout_marginTop="10dp" /&gt; &lt;TextView android:id="@+id/llitx_3" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="今天一天困的要死,昨晚只睡了两小时" android:maxLines="1" android:ellipsize="end" android:textSize="18sp" android:textColor="@color/colorGray" android:layout_marginTop="10dp" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; activity: package com.zly.study.listview;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.widget.ListView;import com.zly.study.R;public class ListViewActivity extends AppCompatActivity &#123; private ListView listView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //设置视图 setContentView(R.layout.activity_list_view); //实例化控件 listView = findViewById(R.id.alv_lv); //设置adapter视图适配器 listView.setAdapter(new MyListAdapter(ListViewActivity.this)); &#125;&#125;//-------------------------------------/** * 列表视图适配器 */public class MyListAdapter extends BaseAdapter &#123; private Context mContext; private LayoutInflater mLayoutInflater; //构造方法传入参数 public MyListAdapter(Context context)&#123; this.mContext = context; mLayoutInflater = LayoutInflater.from(context); &#125; @Override public int getCount() &#123; return 10; &#125; @Override public Object getItem(int position) &#123; return null; &#125; @Override public long getItemId(int position) &#123; return 0; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if(convertView==null)&#123; //设置每个列表项显示的视图效果 //LayoutInflater为布局填充器 convertView = mLayoutInflater.inflate(R.layout.layout_list_item,null); holder = new ViewHolder(); holder.imageView = convertView.findViewById(R.id.lliiv); holder.tvTitle = convertView.findViewById(R.id.llitx_1); holder.tvTime = convertView.findViewById(R.id.llitx_2); holder.tvContent = convertView.findViewById(R.id.llitx_3); convertView.setTag(holder); &#125;else&#123; holder = (ViewHolder) convertView.getTag(); &#125; //给控件赋值(暂时写死) holder.tvTitle.setText("张扣扣被执行死刑"); holder.tvTime.setText("2019-7-25"); holder.tvContent.setText("现在押(编者注:7月17日已被执行死刑)。陕西省汉中市中级人民法院审理汉中市人民检察院指控被告人张扣扣犯故意杀人罪、故意毁坏财物罪一案,于2019年1月8日以(..."); Glide.with(mContext).load("https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1564049123942&amp;di=ac02f5be1ae75a334433933ce78bb3d9&amp;imgtype=0&amp;src=http%3A%2F%2Fpics7.baidu.com%2Ffeed%2F63d0f703918fa0ecb45c6a0535347ceb3c6ddb43.jpeg%3Ftoken%3D7b4af0715ca06cdc29f88a9c569e41e0%26s%3D2A324A868462B35D5C4041120300C090").into(holder.imageView); return convertView; &#125; //子控件存储 static class ViewHolder&#123; public ImageView imageView; public TextView tvTitle,tvTime,tvContent; &#125;&#125; 效果图: 4.网格视图GridView ​ 网格视图(GridView)是按照行、列分布式的方式来显示多个组件，通常用于显示图片或是图标等。在使用网格视图时，首先要在屏幕上添加GridView组件. GridView组件支持的XML属性如表所示： 1.android:numColumns=”4” //GridView的列数设置为4列 2.android:columnWidth=”90dp &quot; //每列的宽度，也就是Item的宽度 3.android:stretchMode=”columnWidth&quot;//缩放与列宽大小同步 4.android:verticalSpacing=”10dp” //两行之间的边距 5.android:horizontalSpacing=”10dp” //两列之间的边距 6.android:cacheColorHint=&quot;#00000000&quot; //去除拖动时默认的黑色背景 7.android:listSelector=&quot;#00000000&quot; //去除选中时的黄色底色 8.android:scrollbars=“none” //隐藏GridView的滚动条 9.android:fadeScrollbars=“true” //设置为true就可以实现滚动条的自动隐藏和显示 10.android:fastScrollEnabled=“true” //GridView出现快速滚动的按钮(至少滚动4页才会显示) 11.android:fadingEdge=“none” //GridView衰落(褪去)边缘颜色为空，缺省值是vertical。(可以理解为上下边缘的提示色) 12.android:fadingEdgeLength=“10dip” //定义的衰落(褪去)边缘的长度 13.android:stackFromBottom=“true” //设置为true时，你做好的列表就会显示你列表的最下面 14.android:transcriptMode=“alwaysScroll” //当你动态添加数据时，列表将自动往下滚动最新的条目可以自动滚动到可视范围内 15.android:drawSelectorOnTop=“false” //点击某条记录不放，颜色会在记录的后面成为背景色,内容的文字可见 ​ 网格视图实现方式与列表视图实现方式类似 xml中: &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="horizontal" android:id="@+id/layout" android:gravity="center"&gt; &lt;GridView android:id="@+id/gridView1" android:layout_width="match_parent" android:layout_height="wrap_content" android:stretchMode="columnWidth" android:numColumns="4"/&gt;&lt;/LinearLayout&gt;&lt;!--//=========================================--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;ImageView android:id="@+id/image" android:paddingLeft="10px" android:scaleType="fitCenter" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:padding="5px" android:id="@+id/title"/&gt;&lt;/LinearLayout&gt; Activity中: public class MainActivity extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); GridView gridView=(GridView)findViewById(R.id.gridView1);//获取GridView组件 //drawable包下存放的图片 int [] imageId=new int[]&#123;R.drawable.img01,R.drawable.img02,R.drawable.img03,R.drawable.img04, R.drawable.img05,R.drawable.img06,R.drawable.img07,R.drawable.img08, R.drawable.img_top,R.drawable.ic_launcher,R.drawable.in,R.drawable.stop,&#125;;//定义并初始化保存图片id的数组 String[] title=new String[]&#123;"图片一","超级图片","魅力图片","碉堡图片","搞笑图片","动画图片","开心图片","难过图片","诡异图片", "心灵鸡汤","虎虎生威","洋洋得意"&#125;;//定义并初始化保存说明文字的数组 List&lt;Map&lt;String,Object&gt;&gt; listitems=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();//创建一个list集合 //通过for循环将图片和列表项文字放到Map中，并添加到List集合中 for(int i=0;i&lt;imageId.length;i++)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;(); map.put("image", imageId[i]); map.put("title",title[i]); listitems.add(map); &#125; //创建SimpleAdapter SimpleAdapter adapter=new SimpleAdapter(this, listitems,R.layout.item,new String[]&#123;"title","image"&#125;,new int[]&#123;R.id.title,R.id.image&#125;); gridView.setAdapter(adapter);//将适配器与gridView关联 &#125;&#125; 效果图: 网格视图代码转载自http://blog.csdn.net/acmman/article/details/44942337 5. RecyclerView ​ RecyclerView是Android 5.0推出的，是support-v7包中的新组件,它被用来代替ListView和GridView，并且能够实现瀑布流的布局，更加高级并且更加灵活，提供更为高效的回收复用机制，同时实现管理与视图的解耦合。 ​ 实现RecyclerView需要先添加依赖com.android.support.recyclerview-v7:版本号 , 版本号要跟sdk版本一致. 示例: xml中 &lt;!--activity_recycle_view.xml---&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/rv_1" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/colorGray" /&gt;&lt;/RelativeLayout&gt;&lt;!--recycle_linear_list_item.xml--&gt;&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="vertical" android:background="#ffffff"&gt; &lt;TextView android:id="@+id/linear_item" android:layout_width="match_parent" android:layout_height="50dp" android:text="天哥在奔跑" android:gravity="center" android:textColor="@color/colorAccent" android:textSize="25sp" /&gt;&lt;/LinearLayout&gt; activity中: public class RecycleViewActivity extends AppCompatActivity &#123; private RecyclerView rv_1; private List&lt;String&gt; list = Arrays.asList("天哥在奔跑_1","天哥在奔跑_2","天哥在奔跑_3","天哥在奔跑_4","天哥在奔跑_5","天哥在奔跑_1","天哥在奔跑_2","天哥在奔跑_3","天哥在奔跑_4","天哥在奔跑_5","天哥在奔跑_1","天哥在奔跑_2","天哥在奔跑_3","天哥在奔跑_4","天哥在奔跑_5","天哥在奔跑_1","天哥在奔跑_2","天哥在奔跑_3","天哥在奔跑_4","天哥在奔跑_5","天哥在奔跑_1","天哥在奔跑_2","天哥在奔跑_3","天哥在奔跑_4","天哥在奔跑_5","天哥在奔跑_1","天哥在奔跑_2","天哥在奔跑_3","天哥在奔跑_4","天哥在奔跑_5"); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_recycle_view); rv_1 = findViewById(R.id.rv_1); //设置布局管理器 rv_1.setLayoutManager(new LinearLayoutManager(RecycleViewActivity.this)); //设置下划线.间隔线什么玩意等等 rv_1.addItemDecoration(new MyDecoration()); //设置adapter rv_1.setAdapter(new LinearAdapter(RecycleViewActivity.this, list, new LinearAdapter.OnItemClickListener() &#123; @Override public void onClick(int pos) &#123; Toast.makeText(RecycleViewActivity.this, "click......" + pos, Toast.LENGTH_SHORT).show(); &#125; &#125;)); &#125; class MyDecoration extends RecyclerView.ItemDecoration&#123; @Override public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.set(0,0,0,getResources().getDimensionPixelOffset(R.dimen.underline_h));//列表加分割线 &#125; &#125;&#125;//================================================================================public class LinearAdapter extends RecyclerView.Adapter&lt;LinearAdapter.LinearViewHolder&gt; &#123; //传入activity private Context mContext; //声明监听器 private OnItemClickListener onItemClickListener; private List&lt;String&gt; list; public LinearAdapter(Context mContext, List&lt;String&gt; list, OnItemClickListener onItemClickListener) &#123; this.mContext = mContext; this.list = list; this.onItemClickListener = onItemClickListener; &#125; @NonNull @Override public LinearAdapter.LinearViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) &#123; //将item传入holder return new LinearViewHolder(LayoutInflater.from(mContext).inflate(R.layout.recycle_linear_list_item, viewGroup, false)); &#125; //组件列表项的数据绑定事件处理 @Override public void onBindViewHolder(@NonNull LinearViewHolder viewHolder, final int i) &#123; if (i % 2 != 0) &#123; //设置内容 viewHolder.mTextView.setText(list.get(i)); &#125; else &#123; viewHolder.mTextView.setText("快下班了!"); &#125; //view的监听器实现使用自定义的onItemClickListener,而这个接口实现则由activity传递进来,实现回调 viewHolder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // Toast.makeText(mContext, "click......" + i, Toast.LENGTH_SHORT).show(); onItemClickListener.onClick(i); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; class LinearViewHolder extends RecyclerView.ViewHolder &#123; //声明布局的控件 private TextView mTextView; public LinearViewHolder(@NonNull View itemView) &#123; super(itemView); mTextView = itemView.findViewById(R.id.linear_item); &#125; &#125; //设置监听回调接口 public interface OnItemClickListener &#123; void onClick(int pos); &#125;&#125; 效果图:]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发学习总结(一)]]></title>
    <url>%2F2019%2F07%2F29%2FAndroid%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Android开发概述以及开发工具 Android开发概述 Android是Google开发的操作系统 Android是一种基于Linux的自由及开放源代码的操作系统，Android 分为四个层，从高层到低层分别是应用程 序层、应用程序框架层、系统运行库层和 Linux 内核层。 Android开发是移动应用开发的表现形式之一 其它表现形式:iOS,H5App,Native+H5,RN,ionic等. Android四大基本组件:Activity、Service、Broadcast Receivet、Content Provider. 特点:系统开源,跨平台,有丰富的应用. Android开发环境 ​ Android基于java的,早期使用eclipse作为IDE,现在比较流行的是Android Studio.它基于IntelliJ IDEA类似Echpse ADT，Android Studio提供了集成的 Android开发工具。相比较以前Eclipse，它自己内部就集成了SDK等，方便开发。通常情况下，在正常安装JDK后，继续安装 Android Studio后，便可直接使用了。 第一个Android应用 ​ 使用Android Studio创建一个安卓应用,我们可以在app/src/main/java/自定义包名/ 下看到MainActivity,这是默认的Activity主入口,直接启动项目就可以在虚拟机环境下看到默认的helloworld页面了. 新建一个Activity步骤: 新建一个java文件,继承于AppCompatActivity类并重写onCreat()方法,设置一个视图View. 在AndroidManifest.xml文件中注册新建的activity实体. 在res/layout包下创建一个xml视图文件,用于展示视图.]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>java</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO 新手搭建教程]]></title>
    <url>%2F2019%2F07%2F23%2FHEXO-%E6%96%B0%E6%89%8B%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[HEXO 新手指南 1.简介 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。 视频观看地址:https://www.bilibili.com/video/av44544186/?spm_id_from=333.788.videocard.15 2.安装必要的软件 进入Node.js官网安装nodeJs,安装完毕后命令行输入node -v 显示版本号,输入 npm -v 显示版本号即安装成功 进入git官网安装git,具体百度 安装hexo, 在命令行中输入 npm install -g hexo-cli 命令行输入hexo -v 显示版本号即安装成功 3. 搭建步骤 1.初始化项目 ​ 在任意目录创建一个文件夹,此文件夹就是博客的工程目录了,比如我创建的路径为 E:/blob/,然后在cmd中进入工程文件目录,输入命令行 hexo init 查看blog目录可以看到生成了很多文件,并且还生成了一个helloword文档,在source/_post目录下,然后输入 hexo s 即可启动项目,浏览器输入localhost:4000即可看到最简单的模型 2. 更换blog主题 ​ 在官网上找一个喜欢的主题或者使用视频里的yilia主题. 在工程根目录使用git bash 克隆工程或者直接下载zip包 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 打开根目录的_config.yml文件,设置主题 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: Butterfly 3. 部署项目到github上 创建一个github账号:https://github.com/ 创建一个repo仓库 Repository name: 账号名.github.io (必须) 进入cmd 输入命令 npm install --save hexo-deployer-git 等待插件下载完成后修改_config.yml,设置仓库地址 # Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/zly1024/zly1024.github.io.git branch: master 部署工程到git hexo d 浏览器访问https://zly1024.github.io 即可看到博客页面(这里输入自己的项目名) 4. 创建新博客 hexo new "博客名" 然后可以以写md文件的软件打开撰写. 重新部署到git hexo cleanhexo ghexo d]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oauth框架搭建]]></title>
    <url>%2F2019%2F07%2F22%2Foauth%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[oauth2总结 前言 1. 什么是oauth OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。 2. 运行流程图 （A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 3. 四种授权模式 1. 授权码模式 授权码模式是四种模式中最繁琐也是最安全的一种模式。 client向资源服务器请求资源，被重定向到授权服务器（AuthorizationServer） 浏览器向资源拥有者索要授权，之后将用户授权发送给授权服务器 授权服务器将授权码（AuthorizationCode）转经浏览器发送给client client拿着授权码向授权服务器索要访问令牌 授权服务器返回Access Token和Refresh Token给cilent 这种模式是四种模式中最安全的一种模式。一般用于client是Web服务器端应用或第三方的原生App调用资源服务的时候。因为在这种模式中AccessToken不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最大限度的减小了AccessToken泄漏的风险。 1.获取授权码请求uri：/oauth/authorize 参数： client_id：客户端id。 response_type：授权类型，此值固定为“code”。 redirect_uri：成功授权后的回调地址 2.获取token请求uri：/oauth/token 参数: client_id：客户端id。 client_secret：客户端密钥 grant_type：授权类型，固定为authorization_code code：授权码 redirect_uri：重定向地址 2. 密码模式 用户将认证密码发送给client client拿着用户的密码向授权服务器请求Access Token 授权服务器将Access Token和Refresh Token发送给client 这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用。 1.获取token请求uri：/oauth/token 参数： username：用户名 password：用户密码 client_id：客户端id client_secret：客户端密钥 grant_type：授权类型，固定为password 3. 客户端模式 这是一种最简单的模式，只要client请求，我们就将AccessToken发送给它。 client向授权服务器发送自己的身份信息，并请求AccessToken 确认client信息无误后，将AccessToken发送给client 这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因此这种模式一般用来提供给我们完全信任的服务器端服务。在这个过程中不需要用户的参与。 1.获取token请求uri：/oauth/token 参数： client_id：客户端id client_secret：客户端密钥 grant_type：授权类型，固定为client_credentials 4. 简化模式 简化模式相对于授权码模式省略了，提供授权码，然后通过服务端发送授权码换取AccessToken的过程。 client请求资源被浏览器转发至授权服务器 浏览器向资源拥有者索要授权，之后将用户授权发送给授权服务器 授权服务器将AccessToken以Hash的形式存放在重定向uri的fargment中发送给浏览器 浏览器访问重定向URI 资源服务器返回一个脚本，用以解析Hash中的AccessToken 浏览器将Access Token解析出来 将解析出的Access Token发送给client 一般简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法使用授权码模式。 注：一般使用前三种模式 4. oauth授权服务器搭建 版本： springboot：1.4.5 security：1.4.5 oauth2：2.0.13 redis：4.0 1. 创建springboot工程并引入oauth相关依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--jwttoken依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--oauth客户端详情数据库存取相关依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 2. OauthConfig配置 @Configuration/** * @EnableAuthorizationServer * 工具方法，用来在当前应用context里(必须是一个DispatcherServlet context) * 开启一个授权server(例如AuthorizationEndpoint)和一个TokenEndpoint。 * server的多个属性可以通过自定义AuthorizationServerConfigurer类型 * (如AuthorizationServerConfigurerAdapter的扩展)的Bean来定制 */@EnableAuthorizationServer@AutoConfigureAfter(WebSecurityConfig.class)public class OAuth2Config extends AuthorizationServerConfigurerAdapter &#123; //AuthenticationManager为认证入口的接口 //通过该接口可以获得用户相关信息、安全实体的标识以及认证请求的上下文信息 @Autowired private AuthenticationManager authenticationManager; @Autowired private DataSource dataSource; @Autowired private RedisCacheProperties redisCacheProperties; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthenticationProvider authenticationProvider; @Value("$&#123;jwt.store.password:zaq12wsx&#125;") private String jwtPass; //jwtToken转换bean 替换oauth默认生成的token @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); KeyPair keyPair = new KeyStoreKeyFactory( new ClassPathResource("jwt.jks"), "zaq12wsx".toCharArray()) .getKeyPair("jwt"); converter.setKeyPair(keyPair); return converter; &#125; //jedis连接工厂bean @Bean("connection4jwt") public JedisConnectionFactory jedisConnectionFactory() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxWaitMillis(redisCacheProperties.getMaxWaitMillis()); jedisPoolConfig.setMaxIdle(redisCacheProperties.getMaxIdle()); jedisPoolConfig.setMaxTotal(redisCacheProperties.getMaxTotal()); JedisConnectionFactory factory = new JedisConnectionFactory(jedisPoolConfig); factory.setHostName(redisCacheProperties.getHost()); factory.setPort(redisCacheProperties.getPort()); factory.setDatabase(1); factory.setPassword(redisCacheProperties.getPassword()); factory.afterPropertiesSet(); return factory; &#125; //设置Token redis存储bean @Bean public TokenStore tokenStore() &#123; RedisTokenStore redisTokenStore = new RedisTokenStore(jedisConnectionFactory()); redisTokenStore.setPrefix("auth-server.jwt"); return redisTokenStore; &#125; //设置基于数据库的客户端详情存取 @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123; clients.jdbc(dataSource); &#125; //用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务(token services)。 @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception &#123; endpoints.authenticationManager(authenticationManager) .accessTokenConverter(jwtAccessTokenConverter())//配置jwt转换器 .authorizationCodeServices(new AuthorizationCodeServices(dataSource))//配置授权码 .tokenStore(tokenStore()).reuseRefreshTokens(false)//配置token存储 .userDetailsService(userDetailsService);//配置基于数据库验证账户密码 //oauth获取token，鉴权token的逻辑都在DefaultTokenServices中，它实现了两个接口 //AuthorizationServerTokenServices ：创建，刷新，获取访问令牌 //ResourceServerTokenServices ：加载凭据，获取token的详情 // 构建TokenServices TokenServices tokenServices = new TokenServices(); tokenServices.setTokenStore(tokenStore()); tokenServices.setSupportRefreshToken(true); tokenServices.setReuseRefreshToken(false); //从数据库获取client详情 tokenServices.setClientDetailsService(endpoints.getClientDetailsService()); tokenServices.setTokenEnhancer(jwtAccessTokenConverter()); endpoints.tokenServices(tokenServices); &#125; //用来配置令牌端点(Token Endpoint)的安全约束. @Override public void configure(AuthorizationServerSecurityConfigurer oauthServer) throws Exception &#123; oauthServer.tokenKeyAccess("permitAll()").checkTokenAccess( "isAuthenticated()").allowFormAuthenticationForClients(); &#125; //ProviderManager 为AuthenticationManager 的认证实现类 //认证方法authenticate() /** 认证流程：1.封装UsernamePasswordAuthenticationToken（主要是将用户输入的用户名密码进行封装，并提供 给AuthenticationManager进行验证，验证成功后，返回一个认证成功的 UsernamePasswordAuthenticationToken对象）设置用户未认证 2.ProviderManager.authenticate() 轮询成员变量List&lt;AuthenticationProvider&gt; providerList，只要其supports函数返回true，就执行该AuthenticationProvider的authenticate 方法，验证成功后重新组装UsernamePasswordAuthenticationToken，并设置用户已认证 注，若要自定义认证方式，则实现AuthenticationProvider接口即可 **/ @Bean public ProviderManager authenticationManager() &#123; List&lt;AuthenticationProvider&gt; providerList = new ArrayList&lt;&gt;(); providerList.add(authenticationProvider); return new ProviderManager(providerList); &#125;&#125; DefaultTokenServices详解：https://www.jianshu.com/p/1fba33b26976 AuthenticationManager 详解：https://www.cnblogs.com/xuwenjin/p/9565356.html 3. AuthenticationProvider实现类 核心代码： @Overridepublic Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; String userName = authentication.getName(); String password = (String) authentication.getCredentials(); UserDetails userDetails = userDetailsService.loadUserByUsername(userName); if (userDetails == null) &#123; logger.debug("Authentication failed: user doesn't exists!"); throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; else &#123; String userPassWord = userDetails.getPassword(); if (userPassWord.equals(password) || userPassWord.equals(PasswordUtil.encodePassword(password, userName)) || userPassWord.equals(PasswordUtil.encodePassword(passwordMd5Encode(password), userName))) &#123; //校验用户是否已过期或被锁住等 if (UserLoginHoldUtil.canUserLoginByAuth(userDetails)) &#123; return new UsernamePasswordAuthenticationToken(userDetails, password, userDetails.getAuthorities()); &#125; else &#123; logger.debug("Authentication failed: user cannot login!"); throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; &#125; else &#123; logger.debug("Authentication failed: password does not match stored value!"); throw new BadCredentialsException(this.messages.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials")); &#125; &#125;&#125; 4. WebSecurityConfig 配置 /** * WebSecurityConfigurerAdapter是默认情况下spring security的http配置 其过滤器链默认值为100 */@Configuration@EnableWebSecurity//指定的类加载完了再加载本类@AutoConfigureAfter(AuthProviderConfig.class)public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Value("$&#123;security.success.defaultTargetUrl:&#125;") private String defaultTargetUrl; @Autowired private AuthenticationProvider authenticationProvider; @Override protected void configure(HttpSecurity http) throws Exception &#123; //security本身是有认证页面的，这里设置security的成功失败的路径等等 SimpleUrlLogoutSuccessHandler logoutSuccessHandler = new SimpleUrlLogoutSuccessHandler(); logoutSuccessHandler.setTargetUrlParameter("redirect_uri"); SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler(); successHandler.setTargetUrlParameter("redirect_uri"); successHandler.setDefaultTargetUrl(defaultTargetUrl); http.httpBasic().disable().csrf().disable().logout().logoutSuccessHandler(logoutSuccessHandler).and().formLogin().loginPage("/login").successHandler(successHandler).defaultSuccessUrl(defaultTargetUrl).permitAll().and().authorizeRequests() /** 此处是设置哪些http请求通过，哪些http请求需要被认证， ResourceServerConfigurerAdapter中的http设置会跟web中的功能一样 不过ResourceServerConfigurerAdapter的过滤器链默认执行顺序为3 **/ .antMatchers("/oauth/**").permitAll() .antMatchers("/register", "/usr/verifyUserName", "/usr/sendVerifyCode", "/usr/register").permitAll() .antMatchers("/fp_phone", "/fp_reset", "/usr/fp/verifyPhoneEffect", "/usr/fp/resetPwd").permitAll() .antMatchers("/MP_verify_RIPzMyhi7TAhrr1q.txt").permitAll() //保证微信内不提示安全验证信息 .anyRequest().authenticated(); &#125; //security认证配置，使用自定义的认证类 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.authenticationProvider(authenticationProvider); &#125;&#125; ResourceServerConfigurerAdapter 与WebSecurityConfigurerAdapter 对比详解：https://www.jianshu.com/p/fe1194ca8ecd 5. 授权码生成实现类AuthorizationCodeServices 核心代码： @Overridepublic String createAuthorizationCode(OAuth2Authentication authentication) &#123; String code = generator.generate(); store(code, authentication); return code;&#125; 继承于默认实现类JdbcAuthorizationCodeServices：存储code于数据库表oauth_code中，删除code 又继承于默认实现类RandomValueAuthorizationCodeServices 5. 资源服务器搭建 1. 引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-jwt&lt;/artifactId&gt;&lt;/dependency&gt; 2. ResourceServerConfig 配置 /** * 资源服务配置. * * @author zly */@Configuration/**资源服务器通过 @EnableResourceServer 注解来开启一个 OAuth2AuthenticationProcessingFilter 类型的过滤器解析令牌的方法1.使用 DefaultTokenServices 在资源服务器本地配置令牌存储、解码、解析方式**/@EnableResourceServer@ConditionalOnProperty(name = "security.enabled", havingValue = "true")public class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; /*每个服务依赖时资源id为应用名字*/ @Value("$&#123;spring.application.name:spring-boot-application&#125;") private String resourceId; @Value("$&#123;jwt.store.password:zaq12wsx&#125;") private String jwtPass; @Override public void configure(ResourceServerSecurityConfigurer resources) &#123; resources.resourceId(resourceId);//（必须配） //资源服务配置tokenServices（非必须） resources.tokenServices(defaultTokenServices()); &#125; @Override public void configure(HttpSecurity http) throws Exception &#123; http.requestMatcher(new OAuthRequestedMatcher()).authorizeRequests().antMatchers(HttpMethod.OPTIONS).permitAll() .anyRequest().authenticated(); &#125; @Bean public UserDetailsService userDetailsService() &#123; return new OAuthUserDetailsService(); &#125; //DefaultAccessTokenConverter又使用DefaultUserAuthenticationConverter来做用户密码角色相关 //若为非对称加密必须配 @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); KeyPair keyPair = new KeyStoreKeyFactory( new ClassPathResource("jwt.jks"), jwtPass.toCharArray()) .getKeyPair("jwt"); converter.setKeyPair(keyPair); //可不配置 DefaultAccessTokenConverter accessTokenConverter = new DefaultAccessTokenConverter(); DefaultUserAuthenticationConverter userAuthenticationConverter = new DefaultUserAuthenticationConverter(); userAuthenticationConverter.setUserDetailsService(userDetailsService()); accessTokenConverter.setUserTokenConverter(userAuthenticationConverter); converter.setAccessTokenConverter(accessTokenConverter); return converter; &#125; //若不配置会使用内存存储（则无法解析） //配置jwtTokenStore，解析token用到的是jwtAccessTokenConverter @Bean public TokenStore tokenStore() &#123; JwtTokenStore tokenStore = new JwtTokenStore(jwtAccessTokenConverter()); return tokenStore; &#125; //（非必须） @Bean public ResourceServerTokenServices defaultTokenServices() &#123; final DefaultTokenServices defaultTokenServices = new DefaultTokenServices(); defaultTokenServices.setTokenEnhancer(jwtAccessTokenConverter()); defaultTokenServices.setTokenStore(tokenStore()); return defaultTokenServices; &#125; //（非必须） //http请求过滤 private static class OAuthRequestedMatcher implements RequestMatcher &#123; public boolean matches(HttpServletRequest request) &#123; String auth = request.getHeader("Authorization"); // Determine if the client request contained an OAuth Authorization boolean haveOauth2Token = (auth != null) &amp;&amp; StringUtils.startsWithIgnoreCase(auth, "Bearer"); boolean haveAccessToken = request.getParameter("access_token") != null; return haveOauth2Token || haveAccessToken; &#125; &#125;&#125; ResourceServerConfig详解：https://www.jianshu.com/p/6dd03375224d 3. WebSecurityConfig 配置 /** * @author zly */@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)//@EnableGlobalMethodSecurity(prePostEnabled = true)@ConditionalOnProperty(name = "security.enabled", havingValue = "true") public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.cors().and() .authorizeRequests() .antMatchers(HttpMethod.OPTIONS).permitAll() .antMatchers("/wxAdapter", "/wxAdapter/*").permitAll() .anyRequest().authenticated() .and().httpBasic() .and().csrf().disable(); &#125;&#125; 最好的放开方式，resourceServerConfig中不配置请求过滤，在security的配置中使用，因为security在 yml文件里有已存在的标签来控制。 6. 认证授权全流程过程以及源码分析 1.第一步：登陆认证 用户访问受限的资源服务页面,页面判断code的存在跳转到授权服务器登陆页面（我的redirect_uri设置为localhost：8083，即我资源服务器地址为localhost：8083)，请求url为： http://localhost:9999/oauth/authorize?response_type=code&amp;client_id=shopapp&amp;redirect_uri=http://localhost:8083 获取code时先判断用户是否已认证： security认证入口： Authentication.authenticate():默认实现类ProvideManager 此类有一个成员变量List providerList = new ArrayList&lt;&gt;(); 最后执行的是AuthenticationProvider.authenticate();下图是自定义的AuthenticationProvider对象 登陆认证完成之后会返回Authentication对象（实现类UsernamePasswordAuthenticationToken），然后会将对象中的password清除 最后会将对象存入SecurityContext中 之后会再次回到获取code的接口中，生成code，然后oauth会跳转到redirect_uri并带上code和state参数。 2.第二步：授权 在资源页面js中根据code和redirect_uri手动构造请求访问授权服务器获取token 经过校验传递的参数是否合法之后，会进入到TokenGranter接口-----&gt;AbstractTokenGranter抽象类的grant()方法获取token 最终的执行方法是DefaultTokenServices.createAccessToken() 若DefaultTokenServices中配置了TokenEnhance会执行其enhance方法替换之前生成的token格式 一般是配置jwtAccessTokenConverter 生成token成功之后会返回ResponseEntity对象，最终返回给前端，存入localstage或页面其他地方。 3.第三步：鉴权 用户访问资源需在请求头带上Authorization键，值为bearer+空格+accessToken，就能进入鉴权入口进行鉴权，鉴权通过之后即可访问资源 然后使用Oauth2AuthenticationManager的authenticate方法鉴权认证 再进入DefaultTokenServices的loadAuthentication方法 1.执行jwtTokenStore–jwtAccessTokenConverter–DefaultAccessTokenConverter里d的方法extractAccessToken()并返回OAuth2AccessToken对象 2.执行jwtTokenStore–jwtAccessTokenConverter–DefaultAccessTokenConverter里的方法extractAuthentication()，并使用DefaultUserAuthenticationConverter的extractAuthentication方法(若配置了userDetailsService，则会去从数据库中获取角色，优先使用的时数据库返回的user和角色)返回UsernamePasswordAuthenticationToken对象 解析token方法 鉴权认证通过之后，比对resourceIds和资源本身的resourceId 若比对成功则鉴权通过，可以访问到需访问的资源]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new "My New Post" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
</search>
